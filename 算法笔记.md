算法笔记
======

* 实现二叉树的先序,中序,后序遍历,递归和非递归方式
	* 递归方式就是打印语句放在第一行,中间,还是最后
	* 非递归方式
		1. 先序遍历
			准备一个栈,push head节点,然后循环(弹出最上面的,打印,每次按照先右子节点,后左子节点的顺序压入栈)
		2. 中序遍历
			1. 准备一个栈,如果当前节点不为空或者栈不为空,
				1. 一直压入左节点,
				2. 如果当前节点为空,从栈中弹出节点打印,并将当前节点指向打印节点的右节点
		3. 后序遍历
			1. 准备一个栈1,push head节点,然后循环(弹出最上面的,存入栈2,然后按照先左节点,后右节点入栈)
			2. 最后依次弹出栈2的节点


![avatar](pic/二叉树的遍历过程.png)


* 反转单向链表

* 之字形打印
	思路:
	1. 指针a往右走,到底之后往下
	2. 指针b往下走,到底之后往右
	3. 按照ab之间的连线打印数字

* 判断链表有没有环,并返回入环节点(IsRingNodeList.java)
	解法一:
	1. 遍历链表,使用Set保存出现过的节点,然后返回重复出现的
	2. 时间N,空间N
	解法二:
	1. 快指针一次两步,慢指针一次一步,在环里相遇后快指针回到headNode,
	2. 快指针,慢指针同时一次走一步前进,相遇的地方就是入环节点
	3. 时间N,空间1

* 判断两条单向链表是否相交,返回第一个相交的节点(IsNodeListIntersect.java)
	* 一条有环,一条无环,不可能相交
	* 两条无环的链表
		1. 遍历两条链表,记录长度和最后一个节点
		2. 判断最后一个节点是否是同一个节点,不是的话不可能相交
		3. 计算长度差,假设是d,长的链表先从头走d步,然后两个一起遍历,第一个相等的节点就是相交
	* 两个都有环
		1. 两个不相交
			* 分别找到入环节点,其中一个入环节点开始遍历,与另一个入环节点比较,要是回到入环节点的时候还没有相等,说明不相交
		2. 拓扑2
			* 入环节点相等,然后以入环节点为终点,相当于找无环链表相交的节点
		3. 拓扑3
			* 入环节点不相等,但是遍历过程中找到另一个入环节点,返回任意一个入环节点

![avatar](pic/单向链表环问题.png) 

#### tip
* 计算mid
	* 使用`L+(R-L)/2`比`(L+R)/2`安全,因为不用担心下标越界,也可以写成位运算`L+(R-L)>>1`
	* 为什么:在计算不能整除的负数下标和的时候可能会越界,不过一般用不到

#### 各种排序算法以及优缺点
>参考地址:https://blog.csdn.net/speedme/article/details/23021467

* 递归函数的时间复杂度计算master公式
	* 能够匹配公式:`T(N) = a*T(N/b) + O(N^d)`的都能按照以下式子估算:
		1. loga(b) > d -> O(N^loga(b))
		2. loga(b) = d -> O(N^d * logN)
		3. loga(b) < d -> O(N^d)

* 工程上的综合排序
	1. 普通类型(int,double,short等):快速排序
	2. 自定义的类:归并排序
	3. 长度很小的数组(小于60?):插入排序
		因为常数项小


* 时间复杂度为O(N^2)的三个排序
	* 冒泡排序 bubbleSort (与数据状况无关),可以稳定
	    * 每一趟遍历将最大的或者最小的交换到一边,下一次就遍历就不经过它了,时间复杂度`O(N^2)`,额外空间复杂度`O(1)`
	* 插入排序 insertionSort (和选择排序的区别就在于,当数组有序的时候遍历一次就行了,也就是和数据状况有关,可以稳定)
	    * 从第二个数字开始到最后一个数字,每次将这个数字与之前的数字作比较,大(或者小)就和前面的数字交换,直到不符合条件,时间复杂度最好`O(n)`,最差`O(n^2)`,空间`O(1)`
	* 选择排序 selectionSort(工程上几乎不用,与数据状况无关,不稳定)
	    * 每一次遍历选择最大或者最小的数,和这一次遍历开头的数交换,时间复杂度`O(n^2)`,空间复杂度`O(1)`
	
* 时间复杂度为`O(N*logN)`的三个排序
	* 归并排序 mergeSort (可以稳定)
	    * 递归,将数组分成两部分,分别排好序然后在合并(通过外排),时间复杂度`O(N*logN)`,额外空间复杂度`O(n)`
	    * 算法步骤:
		    1. 归并主函数:`void mergeSort(int[] arr)`,调用`mergeProcessor(arr,0,arr.length-1)`
		    2. 递归调用函数:`void mergeProcessor(int[] arr,int L, int R)`,当`L==R`的时候返回,计算`mid`,调用`mergeProcessor(arr, L, mid),mergeProcesser(arr, mid + 1, R)`,调用`merge(arr, L, mid, R)`,
		    3. 合并函数:`void merge(int[] arr, int L, int mid, int R)`,新建`int helper[R-L+1]`(可以生成一个全局的,就不用一直生成销毁),将两部分数组按顺序填入
	* 快速排序 quickSort (不稳定)
	    * 快速排序的主要思想是,在数组中随机找到一个数字作为基数,然后将大于这个数的放到它一边,小于它的数放在另外一边,然后左右再次进行相同的操作,直到排序完成.因为等于基数的元素也会被移动位置,所以快排是不稳定的.
	    * 经典快排的缺点:总是拿最后一个数去作为pivot,这样就会和数据状况很有关,最坏的情况就是有序数列排序的话时间复杂度就是O(N^2)
	    	* 时间复杂度`O(N*logN)`,额外空间复杂度`O(logN)`
	* 堆排序 heepSort (堆就是完全二叉树,不稳定)
		* 满二叉树:就是最后一层的叶节点全部补齐(是特殊的完全二叉树)
		* 完全二叉树:如果最后一层没有全部补齐,那么需要从左到右依次补齐.
		* 数组转换成完全二叉树:
			* 当前节点的叶节点:左:`2*i+1`,右:`2*i+2`,越界则说明没有
			* 当前节点的父节点:`(i-1)/2`
		* 大根堆:每一棵子树的最大值都是这课子树的头部
		* 将一个数组排成大根堆(heapInsert)的时间复杂度:`O(N) = log1 + log2 + log3 + ... + log(N-1)`
		* heapIfY:如果大根堆中有一个数字变小了,将对重新调整成大根堆
* 有关排序问题的补充:
	1. 归并排序的额外空间复杂度可以变成O(1),但是很难,"归并排序 内部缓存法"
	2. 快排可以做到稳定,但是很难,"01 stable sort"
	3. 题目:一个数组,奇数放左边,偶数放右边,要求原始相对次序不变,时间复杂度O(N),额外空间复杂度O(1)

* 比较器:继承`Comparator<Student>`接口,实现`compare(Student s1,Student s2)`方法
	* 返回负数:第一个参数放前面
	* 返回正数:第一个参数放后面
	* 返回0:相等

* 系统提供的堆
	1. PriorityQueue(实质上是一个堆结构),构造的时候传入比较器

* 非基于比较的排序
	1. 桶排序
		2. 计数排序
		3. 基数排序





#### 常见算法题

* 小和问题 (LittleSum.java)
	1. 在一个数组中,每一个数左边比这个数小的数累加起来,叫做这个数组的小和,求一个数组的小和.
	2. 思路:这个过程就相当于找每一个数右边有几个数比当前数大,然后将当前数x上个数,然后累加,这个过程可以在**归并排序**的过程中进行计算
	在merge的过程中,在左边数组和右边数组比较的同时计算小和,只要将左边数组比右边小的数字直接乘上右边数组中比他大的数字的个数
	3. 为什么能够加速:因为每次左右数组比较的时候,当左边的数字比右边小的时候,就可以根据右边数组的下标直接得到右边数组有几个比左边数组这个数大

* 逆序对问题 
	1. 类似于小和问题,在归并的过程中直接就可以将逆序对输出

* 荷兰国旗问题(HollandNationFlag.java)
	1. 给定一个数组arr,一个数num,将小于,等于,大于num的数字放在左中右,要求额外空间复杂度O(1)(意思就是不用辅助数组),时间复杂度O(N)(遍历数组的次数固定)
	2. 思路:就是快排的partition函数改一下,smaller从左往右,bigger从右往左,因为还有一个==要比较,相当于小于区域推着等于区域往前走,这个修改后的partition函数可以用来优化之前的快快排
	
* 找中位数
	1. 有一个流一直在输出数,可以用一个数组接受,然后随时取得数组的中位数
	2. 思路:用一个大根堆和一个小根堆,大根堆存放较小的一半数字,小根底存放较大的一半数字,每次接收数字后放到数字较少的数组,然后调整堆,那么堆顶的数字有一个是中位数.

* 找最大差值(MaxGap.java)
    1. 给定一个数组,求排序之后的相邻两个数字之间的差值的最大值,要求时间复杂度O(N):
	2. 思路:由于时间复杂度要求,所以不能用普通的排序,可以使用桶排序
		1. 按照数组中最大值和最小值的差值确定每个桶的存放数字范围,最大值放在len位置,最小值放在0位置,所以桶的数量为len+1,必有一个空桶
		2. `index = (int)((num - min) * len / (max - min))`确定一个数应该放在哪里
		2. 每个同种只存放这个桶的最大值最小值以及同种是否有数,
		3. 遍历桶,求当前桶的最小值和上一个非空桶的最大值的差值,(前提是有非空桶,不然每个桶中最大最小的差值也要加入比较)
		
* 两个队列实现栈(StackByQueue.java)
	1. data队列和help队列
	2. 需要pop的时候先将data队列除了最后一个数的其他数字poll到help队列中,返回data中最后一个数
	3. 交换data和help的引用

* 两个栈实现队列(QueueByStack.java)
	1. push栈和pop栈
	2. 只要pop栈中有元素,就不能从push栈中倒元素到pop
	3. 倒元素要一次全部倒完

* 判断回文链表(IsPalindrome.java),比如1221,12321

	解法一:
	1. 将链表依次弹入栈,然后遍历链表同时依次弹出栈,比较,时间复杂度O(N),额外空间O(N)
	
	解法二:
	1. 定义两个指针,一个快指针,一个慢指针,通过他们找到链表中点,记住中点和最后一个节点
	2. 将中点指向null,中点之后的节点逆序
	3. 然后比较两侧的节点,最后要还原节点指向
	4. 时间复杂度O(N),额外空间复杂度O(1)

* 回旋打印数组
	思路:先确定左上角和右下角,然后打印边框,分成4个边打印,然后缩小左上角和右下角

* 给定一个链表和一个数字num,将链表中大于num的放右边,等于num的放中间,小于num的放左边(PartitionNodeList.java)
	解法一:
	1. 将链表的节点放在数组中,写一个partition函数排好,再串成链表
	2. 时间复杂度O(N),额外空间O(N)
	解法二:
	1. 准备三个节点,less,equal,more
	2. 遍历链表,将less指向第一个小于num的,equal指向第一个指向num的,more指向第一个大于num的
	3. 时间复杂度O(N),额外空间O(1)
	3. 再次遍历链表,相应的节点分配到三个部分

* 拷贝链表(CopyRandomNodeList.java)
	链表的每一个节点除了包含nextNode指针信息,还有一个randomNode指针,实现一个方法,返回拷贝出来的链表的头指针
	解法一:
	1. 使用一个Map<Node, Node>保存原节点,复制节点的信息,然后通过遍历原链表,来确定复制节点的nextNode和randomNode应该指向哪里
	2. 时间N,空间N
	解法二:
	1. 将原链表的每一个节点的指向它的复制节点,复制节点指向原来的下一个节点
	2. 复制节点的random指针指向的就是原节点的random指针指向节点的下一个节点
	3. 分离链表









